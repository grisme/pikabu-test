## **Общая информация**

При архивировании, я предварительно удалил директорию Pods, чтобы не тащить их в архиве c репозиторием. Соответственно, необходимо будет установить их, вызвав pod install в корневой директории проекта из терминала


## **Верстка и UI**

UI реализовал без использования Storyboard и XIB. В самом элементарном представлении, как было сказано в описании к заданию (только базовые контролы iOS). Применил так называемую "верстку кодом", используя SnapKit для constraint'ов.
Storyboard и XIB, как мне кажется, удобно применять для небольших проектов, которые разрабатываются одним разработчиком или для MVP, где нужно быстро на коленке реализовать что-то похожее на прототип. В командной разработке Storyboard-файлы будут часто создавать конфликты.

Реализовал минимальную поддержку темной темы для приложения (описал несколько цветов auto* в расширении UIColor, в которых определяется версия iOS, предоставляется system цвет для iOS 13+ и необходимый дефолтный для iOS < 13)


## **Архитектура**

При разработке, применил (точнее, постарался :) архитектурный паттерн VIPER, который был описан многими специалистами по-разному. Я стараюсь применять концепцию VIPER + RxSwift для связки модульных элементов между собой, которую описал Дмитрий Котенко из tutu на конференции CocoaHeads (ссылка на доклад: https://www.youtube.com/watch?v=VLlxOuE0KLQ). 
Таким образом каждый элемент модуля VIPER описывается одним протоколом с торчащими наружу Rx-рычажками, а не двумя протоколами, где торчат рычажки на вход (так сказать Input-протокол) и протокол для обратного оповещения (так сказать Output-протокол).

Практикую связку и без RxSwift, в зависимости от проекта.

Все элементы модулей закрыты протоколами, через которые "общаются" между собой. Полезно для написания тестов, например. Если создать mock-объект с тем же протоколом, можно легко подменить любой элемент модуля

RxSwift, помимо прочего, удобно применять, чтобы строить цепочки вызовов, с промежуточными обработчиками (например, после выполнения запроса, в слое интерактора нужно что-то сохранить в кэш, а затем обработка дойдет до презентера), диспетчеризацией на разные потоки выполнения и так далее. Или, например, когда необходимо объединить несколько Observable-элементов в группу и обработать общий результат / ошибку (например, несколько сетевых запросов при запуске модуля приложения)

Ну и на базе Rx получаются примерно похожие приложения по концепции для Android и iOS 


## **Библиотеки**

### UI pods
SnapKit - constraint'ы на базе AutoLayout с удобным декларативным синтаксисом
Kingfisher - библиотека для загрузки изображений по URL с автоматическим умным кэшем

### RxSwift pods
RxSwift - для реактивной связки элементов модуля VIPER

### Networking pods
Alamofire - известная сетевая библиотека для Swift (потомок AFNetworking для Objective C), полезна так как имеет достаточно большую кучу надстроек над стандартным NSURLSession'ом от Apple. Как то, например, Request Retrier, который можно применить для удобной фоновой переавторизации по истечению токена авторизации. Имеет и ряд недостатков, который в целом не ощутимы при разработке более-менее стандартных приложений. 

